{{>header_for_modifications}}

unit {{programName}}Client;

interface
uses
  System.SysUtils,
  System.Net.URLClient,
  Neon.Core.Persistence,
  whizaxe.openapi.config,
  whizaxe.openapi.security,
  whizaxe.Rest.exceptions,
  Generics.Collections,
  Rest.Types,
  Rest.Client,
  Rest.Authenticator.OAuth,
  rest.Authenticator.Basic,{{#apiInfo}}{{#apis}}{{#operations}}
  {{classname}}Interface{{^-last}}, {{/-last}}{{/operations}}{{/apis}}{{/apiInfo}}{{#models}}{{#-first}},{{/-first}}{{#model}}
  {{classFilename}}{{/model}}{{^-last}}, {{/-last}}{{/models}}
  , Model.ExtInfo
  , System.Classes
  , superobject;
  
  
type
  T{{programName}}Client = class(TInterfacedObject, {{#apiInfo}}{{#apis}}{{#operations}}
    I{{classname}}{{^-last}}, {{/-last}}{{/operations}}{{/apis}}{{/apiInfo}})
  private
    FOnAuthenticate: TAuthenticateEvent;
    FConfig: TOpenApiConfig;
    FAuth: IOpenApiSecurity;
    FParseResponseErrors: boolean;
    procedure SetOnAuthenticate(const Value: TAuthenticateEvent);
    function GetRESTRequestMethod(const AMethodName: string): TRESTRequestMethod;
    function MakeRestClient: TRestClient;
       function MakeNeonConfiguration: INeonConfiguration;
    function ParseResponseErrorToRestException(AResponse: TCustomRestResponse): EWxRestException;
    function TryExecuteRequest(ARequest: TRestRequest): boolean;
    
    procedure hndValidateCertificate(const Sender: TObject; const ARequest: TURLRequest; const Certificate: TCertificate; var Accepted: Boolean);
  public
    constructor Create(AConfig: TOpenApiConfig; AParseResponseErrors: boolean = false);
    destructor Destroy; override;

    property OnAuthenticate: TAuthenticateEvent read FOnAuthenticate write SetOnAuthenticate;

    {{#apiInfo}}{{#apis}}{{#operations}}
    { {{baseName}} }

    {{#operation}}
    /// Operation {{{operationId}}}
    /// <summary>{{{summary}}}</summary>
    /// <remarks>{{remarks}}</remarks>

    {{#pathParams}}
    /// {{baseName}}: {{description}} {{#required}}(required){{/required}}{{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}{{#isDeprecated}} (deprecated){{/isDeprecated}}
    {{/pathParams}}
    {{#returnType}}function {{{operationId}}}({{#allParams}}const {{{paramName}}}: {{{dataType}}}; {{/allParams}}const authorization: ISuperObject): {{{returnType}}}{{#isDeprecated}}; deprecated{{/isDeprecated}};{{/returnType}}
    {{^returnType}}procedure {{{operationId}}}({{#allParams}}const {{{paramName}}}: {{{dataType}}}; {{/allParams}}const authorization: ISuperObject){{#isDeprecated}}; deprecated{{/isDeprecated}};{{/returnType}}
    
    {{/operation}}
    {{/operations}}{{/apis}}{{/apiInfo}}
  end;

implementation

uses
  System.Net.HttpClient,
  Neon.Core.Types,
  System.TypInfo,
  whizaxe.serialization;

{ TApiClient }

constructor T{{programName}}Client.Create(AConfig: TOpenApiConfig; AParseResponseErrors: boolean);
var
  lClient: TRESTClient;
  auth: TOAuth2Authenticator;
begin
  FConfig := AConfig;
  FParseResponseErrors := AParseResponseErrors;
  {{#authMethods}}
  {{#isBasicBearer}}FAuth := TOpenApiSecurityBearer.Create('<put your token here>', nil){{/isBasicBearer}}
  {{^isBasicBearer}}FAuth := TOpenApiSecurityNone.Create(){{/isBasicBearer}}  
  {{/authMethods}}

end;

destructor T{{programName}}Client.Destroy;
begin
  FConfig.Free;
  FAuth := nil;

  inherited;
end;

function T{{programName}}Client.GetRESTRequestMethod(const AMethodName: string): TRESTRequestMethod;
var
  methodName: string;
begin
  methodName := AMethodName.ToUpper();
  if methodName = 'POST' then
    Result := rmPOST
  else if methodName = 'PUT' then
    Result := rmPUT
  else if methodName = 'DELETE' then
    Result := rmDELETE
  else if methodName = 'PATCH' then
    Result := rmPATCH
  else
    Result := rmGET;
end;

procedure T{{programName}}Client.SetOnAuthenticate(const Value: TAuthenticateEvent);
begin
  FOnAuthenticate := Value;
end;

function T{{programName}}Client.MakeNeonConfiguration: INeonConfiguration;
begin
  {{^variableNameConvertUnderscoreToCamelCase}}Result := nil;{{/variableNameConvertUnderscoreToCamelCase}}{{#variableNameConvertUnderscoreToCamelCase}}Result := TNeonConfiguration.Default;
  Result.SetMemberCase(TNeonCase.SnakeCase);
  Result.SetMembers([TNeonMembers.Fields, TNeonMembers.Properties]);
  Result.SetIgnoreFieldPrefix(True);
  Result.SetVisibility([ mvPublic, mvPublished]);
  Result.SetUseUTCDate(false);
  Result.SetEnumAsInt(false);{{/variableNameConvertUnderscoreToCamelCase}}
end;

function T{{programName}}Client.MakeRestClient: TRestClient;
begin
  Result := TRESTClient.Create(FConfig.basePath);
  Result.SecureProtocols  := FConfig.TLSVersions;
  Result.OnValidateCertificate := hndValidateCertificate;  
  
  {{#authMethods}}{{#isBasicBearer}}
  Result.Authenticator := FAuth.CreateAuthenticator;
  {{/isBasicBearer}}{{/authMethods}}
  if Assigned(Result.Authenticator) then
    Result.Authenticator.OnAuthenticate := OnAuthenticate;
end;

procedure T{{programName}}Client.hndValidateCertificate(const Sender: TObject; const ARequest: TURLRequest; const Certificate: TCertificate; var Accepted: Boolean);
begin
  Accepted := Accepted or FConfig.ignoreCertificateErrors;
end;

function T{{programName}}Client.ParseResponseErrorToRestException(AResponse: TCustomRestResponse): EWxRestException;
var
  RestErrorModel: TWxRestErrorModel;
begin
  RestErrorModel := TSerializer.JsonToObject<TWxRestErrorModel>(AResponse.Content);
  try
    case AResponse.StatusCode of
      400:
        Result := EWxRestValidationException.Create(RestErrorModel.message, RestErrorModel.errorCode);
      422:
        Result := EWxRestBusinessLogicException.Create(RestErrorModel.message, RestErrorModel.errorCode);
    else
      Result := EWxRestException.Create(RestErrorModel.message, AResponse.StatusCode, RestErrorModel.errorCode);
    end;
  finally
    RestErrorModel.Free;
  end;
end;

function T{{programName}}Client.TryExecuteRequest(ARequest: TRestRequest): boolean;
var
  errorMessage: string;
begin
  Result := false;
  try
    ARequest.Execute;
  except
    on E: Exception do
    begin
      if assigned(ARequest.Response) and FParseResponseErrors then
        raise ParseResponseErrorToRestException(ARequest.Response)
      else
        raise EWxRestRawException.Create(E.Message, 0);
    end;
  end;

  if ARequest.Response.StatusCode <> 200 then
  begin
    if FParseResponseErrors then
      raise ParseResponseErrorToRestException(ARequest.Response)
    else
    begin
      if ARequest.Response.ErrorMessage.IsEmpty then
      begin
        errorMessage := ARequest.Response.Content;
        if errorMessage.IsEmpty then
          errorMessage := format('%d %s', [ARequest.Response.StatusCode, ARequest.Response.StatusText]);
      end
      else
        errorMessage := ARequest.Response.ErrorMessage;

      raise EWxRestRawException.Create(errorMessage, ARequest.Response.StatusCode);
    end
  end
  else
    Result := true;
end;

{{#apiInfo}}{{#apis}}{{#operations}}
{{#operation}}
{{#returnType}}function T{{programName}}Client.{{{operationId}}}({{#allParams}}const {{{paramName}}}: {{{dataType}}}; {{/allParams}}const authorization: ISuperObject): {{{returnType}}};{{/returnType}}{{^returnType}}procedure T{{programName}}Client.{{{operationId}}}({{#allParams}}const {{paramName}}: {{{dataType}}}; {{/allParams}}const authorization: ISuperObject);{{/returnType}}
var 
  restRequest: TRestRequest;
  restClient: TRestClient;
  neonConfiguration: INeonConfiguration;
begin
  neonConfiguration := MakeNeonConfiguration;
  restClient := MakeRestClient;
  {{#returnType}}{{^returnSimpleType}}Result := nil;{{/returnSimpleType}}{{/returnType}}
  restRequest := TRESTRequest.Create(restClient);
  try
    restRequest.Resource := '{{path}}';
    restRequest.Method := GetRESTRequestMethod('{{httpMethod}}');
    {{#pathParams}}
    restRequest.AddParameter('{{baseName}}', {{^isString}}{{#isBoolean}}BoolToStr({{{paramName}}}, true){{/isBoolean}}{{^isBoolean}}{{#isNumber}}CurrToStr({{{paramName}}}){{/isNumber}}{{#isEnumRef}}TSerializer.SerializeSimple<{{{dataType}}}>({{{paramName}}}, neonConfiguration){{/isEnumRef}}{{^isEnumRef}}{{^isNumber}}{{{paramName}}}.ToString(){{/isNumber}}{{/isEnumRef}}{{/isBoolean}}{{/isString}}{{#isString}}{{{paramName}}}{{/isString}}, pkURLSEGMENT);
    {{/pathParams}}
    {{#queryParams}}
    restRequest.AddParameter('{{baseName}}', {{^isString}}{{#isBoolean}}BoolToStr({{{paramName}}}, true){{/isBoolean}}{{^isBoolean}}{{#isNumber}}CurrToStr({{{paramName}}}){{/isNumber}}{{#isEnumRef}}TSerializer.SerializeSimple<{{{dataType}}}>({{{paramName}}}, neonConfiguration){{/isEnumRef}}{{^isEnumRef}}{{^isNumber}}{{{paramName}}}.ToString(){{/isNumber}}{{/isEnumRef}}{{/isBoolean}}{{/isString}}{{#isString}}{{{paramName}}}{{/isString}}, pkQUERY);
    {{/queryParams}}
    {{#bodyParams}}
    restRequest.AddBody(TSerializer.SerializeObject({{paramName}}, neonConfiguration), TRESTContentType.ctAPPLICATION_JSON);
    {{/bodyParams}}
    
    {{#returnType}}if TryExecuteRequest(restRequest) then
    begin
      {{#vendorExtensions.x-delphi-returns-model}}
      result := {{{.}}}.Create;
      TSerializer.DeserializeObject(result, restRequest.Response.Content, neonConfiguration);
      {{/vendorExtensions.x-delphi-returns-model}}
      {{^vendorExtensions.x-delphi-returns-model}}
      result := restRequest.Response.Content;
      {{/vendorExtensions.x-delphi-returns-model}}
    end
    else {{#vendorExtensions.x-delphi-returns-model}}
      result := nil;{{/vendorExtensions.x-delphi-returns-model}}{{^vendorExtensions.x-delphi-returns-model}}
      result := '';{{/vendorExtensions.x-delphi-returns-model}}
  {{/returnType}}
  {{^returnType}}TryExecuteRequest(restRequest);{{/returnType}}
   
  finally
    restClient.Authenticator.Free;
    restClient.Free;
  end;
end;


{{/operation}}
{{/operations}}{{/apis}}{{/apiInfo}}

end.