{{>header_autogen}}
// template: model-properties

unit {{#models}}{{#model}}{{classFilename}}{{/model}}{{/models}};

interface

uses
  Neon.Core.Types,
  Neon.Core.Attributes,
  Neon.Core.Nullables,
  whizaxe.REST.Exceptions{{#imports}}{{#-first}},{{/-first}}
  {{{import}}}{{^-last}},{{/-last}}{{/imports}};

type{{#models}}{{#model}}{{#isEnum}}
  T{{classname}}Names = class
  public const{{#allowableValues}}{{#enumVars}}
    c{{name}} = '{{{value}}}';{{/enumVars}}{{/allowableValues}}
    {{className}}EnumNames = {{#allowableValues}}{{#enumVars}}
           {{^-first}}+ {{/-first}}c{{{name}}}{{^-last}} + ',' {{/-last}}{{/enumVars}}{{/allowableValues}};
  end;{{/isEnum}}{{/model}}{{/models}}{{#models}}{{#model}}{{#isEnum}}

  [NeonEnumNames(T{{classname}}Names.{{className}}Enumnames)]
  T{{classname}} = (
    {{#allowableValues}}{{#enumVars}}ev{{{name}}}{{^-last}}, {{/-last}}
    {{/enumVars}}{{/allowableValues}}
  );{{/isEnum}}{{^isEnum}}

//  {$RTTI EXPLICIT PROPERTIES([vcPublic])}

  {$RTTI EXPLICIT METHODS([vcPrivate])}
  T{{classname}} = class{{#isArray}}({{{dataType}}}){{/isArray}}
  private
    {{#vendorExtensions.x-delphi-enum}}FValue: TEnum{{classname}};{{/vendorExtensions.x-delphi-enum}}{{#vars}}
    {{vendorExtensions.x-delphi-field-name}}: {{#vendorExtensions.x-delphi-nullable-type}}Nullable<{{{dataType}}}>{{/vendorExtensions.x-delphi-nullable-type}}{{^vendorExtensions.x-delphi-nullable-type}}{{{dataType}}}{{/vendorExtensions.x-delphi-nullable-type}}{{#deprecated}} deprecated{{/deprecated}}; {{#description}}// {{description}}{{/description}}{{/vars}}

    {{#vars}}{{#isModel}}
    procedure {{vendorExtensions.x-delphi-setter-name}}(AValue: {{{dataType}}});{{/isModel}}{{/vars}}

    {{#vars}}
    function {{baseName}}IsValid(out AErrorMessage: string): boolean;
    {{/vars}}

  public
    {{^isArray}}
    constructor Create;
    destructor Destroy; override;
    {{/isArray}}{{#isArray}}{{^items.isPrimitiveType}}
    constructor Create;
    {{/items.isPrimitiveType}}{{/isArray}}
    {{#vars}}
    {{#vendorExtensions.x-delphi-nullable-type}}[NeonInclude(IncludeIf.NotNull)]
    property {{{name}}}: Nullable<{{{dataType}}}>{{/vendorExtensions.x-delphi-nullable-type}}{{^vendorExtensions.x-delphi-nullable-type}}
    property {{{name}}}: {{{dataType}}}{{/vendorExtensions.x-delphi-nullable-type}} read {{vendorExtensions.x-delphi-field-name}} write {{#isModel}}{{vendorExtensions.x-delphi-setter-name}}{{/isModel}}{{^isModel}}{{vendorExtensions.x-delphi-field-name}}{{/isModel}};
    {{/vars}}

    /// <summary>
    /// Validate the current data in the model. Throws a EValidationException on failure.
    /// </summary>
    procedure Validate(); overload;

    /// <summary>
    /// Validate the current data in the model. Returns false and error message for invalid model.
    /// </summary>
    function Validate(out AErrorMsg: string): boolean; overload;

    /// <summary>
    /// Serialize model to JSON
    /// </summary>
    function AsJson: string;

    /// <summary>
    /// Update model from JSON string
    /// </summary>
    procedure UpdateFromJson(AJson: string);

    {{#vars}}{{#isModel}}
    function {{{name}}}IsSet: boolean;{{/isModel}}{{/vars}}
  end;
{{/isEnum}}{{/model}}{{/models}}{{#models}}{{#model}}

implementation
{{^isEnum}}

uses
  System.Classes,
  System.SysUtils,{{#models}}{{#model}}{{#isEnum}}
  whizaxe.reflections,
{{/isEnum}}{{/model}}{{/models}}
  whizaxe.serialization,
  whizaxe.reflections,
  whizaxe.OpenApi.validators;
{{/isEnum}}{{/model}}{{/models}}{{#models}}{{#model}}{{^isEnum}}

{ T{{classname}} }

{{#isArray}}{{^items.isPrimitiveType}}
constructor T{{classname}}.Create;
begin
  inherited Create(true);
end;
{{/items.isPrimitiveType}}{{/isArray}}{{^isArray}}
constructor T{{classname}}.Create;
begin
  inherited Create;
end;

destructor T{{classname}}.Destroy;
begin
  {{#vars}}{{#isModel}}
  {{vendorExtensions.x-delphi-field-name}}.Free;{{/isModel}}{{/vars}}
  inherited;
end;
{{/isArray}}

function T{{classname}}.AsJson: string;
begin
  Result := TSerializer.SerializeObject(self);
end;

procedure T{{classname}}.UpdateFromJson(AJson: string);
begin
   try
    TSerializer.DeserializeObject(self, AJson);
  except
    on E: ENeonException do
      raise EWxRestValidationException.Create('Cannot deserialize json');
  end;
end;

procedure T{{classname}}.Validate;
var
  msg: string;
begin
  if not self.Validate(msg) then
    raise EWxRestValidationException.Create(msg);
end;

function T{{classname}}.Validate(out AErrorMsg: string): boolean;
var
  errorMsg: string;{{^oneOf}}
  sb: TStringBuilder;{{#isArray}}{{#arrayModelType}}
  item: T{{arrayModelType}};
  itemIdx: integer;{{/arrayModelType}}{{/isArray}}
const
  MSG = 'Field %s is not set or has invalid value. %s';{{#isArray}}{{#arrayModelType}}
  MSG_ITEM = 'Invalid item in array at index %d. %s';{{/arrayModelType}}{{/isArray}}{{/oneOf}}{{#oneOf}}
  obj_{{.}}: T{{.}};{{/oneOf}}
begin
  errorMsg := '';
  {{#oneOf}}{{#-first}}// OneOf:{{/-first}}
  obj_{{.}} := nil;{{/oneOf}}{{^oneOf}}
  sb := TStringBuilder.Create;{{#isArray}}{{#arrayModelType}}
  itemIdx := 0;{{/arrayModelType}}{{/isArray}}{{/oneOf}}

  try
    {{#oneOf}}
    obj_{{.}} := TSerializer.CloneNeon<T{{.}}>(self);
    {{/oneOf}}{{#oneOf}}
    if obj_{{.}}.Validate(errorMsg) then
      exit;
    {{/oneOf}}{{^oneOf}}{{#vars}}
    if not {{baseName}}IsValid(errorMsg) then
      sb.AppendLine(format(MSG, ['{{name}}', errorMsg]));
    {{/vars}}

    {{#isArray}}{{#arrayModelType}}
    for item in Self do
    begin
      errorMsg := '';
      item.Validate(errorMsg);
      if errorMsg <> '' then
        sb.AppendLine(format(MSG_ITEM, [itemIdx, errorMsg]));
       Inc(itemIdx);
    end;{{/arrayModelType}}{{/isArray}}{{/oneOf}}
  finally
    {{#oneOf}}
    {{#-first}}
    result := ErrorMsg = '';
    AErrorMsg := ErrorMsg;
    // OneOf:
    {{/-first}}
    obj_{{.}}.Free;
    {{/oneOf}}
    {{^oneOf}}
    AErrorMsg := sb.ToString();
    result := AErrorMsg = '';
    sb.Free;
    {{/oneOf}}
  end;
end;


{$region 'Getters and setters'}
{{#vars}}

{{#isModel}}function T{{classname}}.{{{name}}}IsSet: boolean;
begin
  result :=  Assigned({{vendorExtensions.x-delphi-field-name}});
end;

procedure T{{classname}}.{{vendorExtensions.x-delphi-setter-name}}(AValue: {{{dataType}}});
begin
  if AValue = {{vendorExtensions.x-delphi-field-name}} then
    exit;
  {{vendorExtensions.x-delphi-field-name}}.Free;
  {{vendorExtensions.x-delphi-field-name}} := AValue;
end;
{{/isModel}}{{/vars}}
{$endregion}

{$region 'Validations'}

{{#vars}}
function T{{classname}}.{{baseName}}IsValid(out AErrorMessage: string): boolean;
{{#hasValidation}}var
  validator: IValidator<{{{baseType}}}>;
{{/hasValidation}}
begin
  {{#hasValidation}}
  {{#isString}}
  validator := TStringLengthValidator.Create(nil, {{#minLength}}{{minLength}}{{/minLength}}{{^minLength}}0{{/minLength}}, {{#maxLength}}{{maxLength}}{{/maxLength}}{{^maxLength}}0{{/maxLength}});
  {{/isString}}
  {{#isInteger}}
  validator := TNumberValidator<integer>.Create(nil, {{#minimum}}true, {{minimum}},{{/minimum}}{{^minimum}}false, 0,{{/minimum}}{{#maximum}}true, {{maximum}}{{/maximum}}{{^maximum}}false, 0{{/maximum}});{{#multipleOf}}
  validator := TMultipleOfValidator<integer>.Create(validator, {{multipleOf}});{{/multipleOf}}
  {{/isInteger}}
  {{#isNumber}}
  validator := TNumberValidator<currency>.Create(nil,{{#minimum}} true, {{minimum}},{{/minimum}}{{^minimum}} false, 0,{{/minimum}}{{#maximum}} true, {{maximum}}{{/maximum}}{{^maximum}} false, 0{{/maximum}});{{#multipleOf}}
  validator := TMultipleOfValidator<currency>.Create(validator, {{multipleOf}});{{/multipleOf}}
  {{/isNumber}}
  {{#required}}
  validator.setRequired(true);{{/required}}{{^required}}{{#x-delphi-has-valid-default}}
  validator.setDefault({{{defaultValue}}});{{/x-delphi-has-valid-default}}{{/required}}
  result := validator.Validate({{vendorExtensions.x-delphi-field-name}}, AErrorMessage);{{/hasValidation}}{{^hasValidation}}
  {{#isModel}}result := {{vendorExtensions.x-delphi-field-name}}.Validate(AErrorMessage);{{/isModel}}{{^isModel}}result := true;{{/isModel}}
  {{/hasValidation}}

end;

{{/vars}}
{$endregion}

{{/isEnum}}
{{/model}}
{{/models}}
end.
